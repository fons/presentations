\documentclass[12pt,fleqn]{article}
\usepackage{comment}
\usepackage{nth}
\usepackage{setspace}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code \footnotesize
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\lstloadlanguages{% Check Dokumentation for further languages ...
         %[Visual]Basic
         %Pascal
         %C
         C++
         %XML
         %HTML
         %Java
 }
%%\doublespacing
 
\renewcommand{\familydefault}{\sfdefault}

%
%no math indentation..
%
\setlength{\mathindent}{0pt}
%
% no identtation at the start of a paragraph.
\setlength{\parindent}{0in}
%------------------------

\newenvironment{packed_enum}{
\begin{enumerate}
 \setlength{\itemindent}{-15pt}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_itemize}{
\begin{itemize}
\setlength{\itemindent}{-15pt}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}


\begin{document}
\title{Living  with $\lambda$ 's \\ Functional Programming in C++}
\author {alfons haffmans}
\maketitle

\section* {Introduction}
Functional programming and C++.
The combination will strike an equal mixture of disgust and terror in some of you.
Others may be intrigued and daunted by the prospect.

Yet C++ has always been a multi-paradigm language \cite{stroustrup}.
%%In fact template meta-programming resembles a pure functional language \cite{vandevoorde, alexan}.
Recent additions to the standard have improved the support for functional programming \cite{josuttis}.
In fact, previous attempts to add functional programming features required a significant effort \cite{mcnamara}.
This paper explores the support out-of-box for functional programming provided by the new C++ standard.
We'll look at techniques typically found in introductory textbooks on functional programming \cite{lipovaca, hutton, bird}.
This article assumes familiarity with C++, but not necessarily with functional programming.

The source code is available on github \cite{sourcecode} and is compiled using gcc 4.8 installed on Mac OSX using MacPorts \cite{macports}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section*{Object Oriented and Functional Programming Style}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The heart of object-oriented programming is the encapsulation of data and methods in a class.
Each instance of a class represents an entity in the real world. 
A class is responsible for the management of it's state and as long as it fulfills the contract implied by it's interface the implementation is of no concern to the caller.
Objects interact by sending each other messages through method calls which change the internal state of the receiving object.
Classes can be combined through inheritance or composition to form more complex entities \cite{designpatterns}. 

The for-loop is a typical construct used in the implemention of algorithms in C++.
The for-loop  processes object instances in a container.
An iterator points to the element being processed in the body of the loop.
The body typically has statements which affect the state of the element referenced by the iterator.
When the for-loop reaches the end of the container at least some of its elements have been modified in some way.
Any reference to the list acquired before the for-loop was executed will now reference the changed list.
The same thing goes for references to elements in the list.
So the execution of the for-loop may cause side-effects in other parts of the program, either by design or by accident.
The style of programming which emphasizes the use of mutable data and statements is called an imperative programming style.
Imperative programming makes it hard to prove by simple statement inspection if a program is correct, because its state maybe affected by changes away from statement being reviewed.

By contrast functional programming stresses the construction of functions acting on immutable data.
Data and operations are kept seperate from each other.
Immutable data is a value. 
You can hold a reference to a value like 1, but 1 itself is immutable.
You can add 2 to the reference to 1 but the reference itself still points to 1.
%%%The use of functions acting on immutable data lies at the heart of functional programming.

In a functional language functions are first-class objects. 
You create a reference to a function like any other data type.
Functions can have functions as arguments or return functions.
Functions like that are called higher order functions.
Higher-order functions are used to combine simpler functions into more complex ones.
They play an important role in functional programming.

Recursion replaces for-loops as a control structure for list processing \cite{hutton, bird}.
When you iterate through a list you create a new list containing the results of your operation.
The input list and its elements remain unchanged.
%%%of applying a function to the elements of the old list. 
%%Typically a main function takes a list and a unary operator as an argument. 
%%It also has a third aikergument which is used to collect the new values.
%%The body of this function would unary function on the head of the list.
%%The return value would be stored in a different list, called an accumulator \cite{hutton}.
%%The tail of the list and the accumulator would both be arguments the next call of the main function. 
%%There is an obvious trade off between compactness and speed versus referential transparency.
%%In functional programming languages this tradeoff is small because the new list will reference the old, unchanged elements in its old version.
%%In C++ that is not going to be the case.  Here the pursuit of referential will come with the cost of creating copies. 

Because functions play such an important role we use a formal way to represent them.
This article uses Haskell's notation for function signatures \cite{hutton}. 
Using that notation the function signature of
a binary function {\em f}  with arguments of type {\em a} and {\em b} and a return value of type {\em c} is:
\begin{eqnarray*}
                              f::(a,b) \rightarrow c
\end{eqnarray*}
The representation of function implementations is slightly different.
The $=$ operator separates the argument list from the function definition.  
The double colon {\bf ::} following the argument list defines the return type.
Here's the type signature and implementation of the identity function $id$:
\begin{eqnarray*}
id :: a &\rightarrow& a \\
id (int \; x)::int  &=& x  \\
\end{eqnarray*}

In $a \rightarrow b$ the arrow operator $\rightarrow$ is a generic type which takes two other types $a$ and $b$ to be fully defined.
Types that are parametrized by other types are called type constructors \cite{lipovaca}.

In general $M\;a$ represents a type constructor $M$ which takes a single type variable $a$.
$M\;a$ corresponds to the C++ class template  
$ {\bf template}<\mbox{typename {\bf a}}> \mbox{struct {\bf M}} \{....\}$. 
The equivalent of the arrow operator in C++ is the function wrapper $std::function<a(b)>$ in $<functional>$ \cite{josuttis, std::function}. 
A list of values of type $a$ is created by the type constructor $[a]$.
The equivalent of $[a]$ in C++ are linear containers like $std::list<a>$ or $std::forward\_list<a>$ \cite{josuttis}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                  Main Building Blocks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section*{Lambda Expressions and Closures}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Lambda expressions allow you to create functions on-the-fly. 
A variable referenced in the body of the lambda not defined in its argument list is called a free variable. 
Free variables are assigned values found for them in the environment preceding the definition of the lambda expression \cite{field}. 
A closure is created by this capture of the enclosing environment by the lambda \cite{field, scott}. 
\newline
The (slightly abbreviated) C++ syntax for the lambda expression is \cite{lambdaref}:
%%---------------
\[
\begin{array}{rll}
[...] \;  (params) \; mutable \;  \rightarrow \; rettype \;\; \{ \; body \;\}
\end{array}
\]
%%------------
The specifier $[...]$ determines the way free variables are captured.
If it's empty $[]$, the body of the lambda can't have any free variables.
The $[=]$ specifier captures free variables by value, whereas the $[\&]$ captures them by reference.
When the specifiers $=$ or $\&$ are followed by the name of free variable only that variable will be captured. 
The return type specifier $\rightarrow \; rettype$ is optional.
The keyword $mutable$ allows the lambda to modify free variables captured by value. 
\newline
Lambda's can be assigned to variables declared using $std::function$ \cite{std::function} or auto \cite{auto}.
The new keyword $auto$ allows you the elide a full type specification, reducing the line noise in the code.
%
\begin{lstlisting}[caption=various ways lambda's capture the environment , label=listing1]
[...]
  int x = 0;
  int y = 42;
  auto func = [x, &y] () { std::cout << "Hello world from lambda : " << x << "," << y << std::endl; };
  auto inc = [&y] () { y++; };
  auto inc_alt = [y]  () mutable { y++; };
  auto inc_alt_alt = [&]  () { y++; x++; };

  func(); //prints: Hello world from lambda : 0,42
  y = 900;
  func(); //prints:  Hello world from lambda : 0,900

  inc();
  func(); //prints : Hello world from lambda : 0,901

  inc_alt();
  func(); //prints: Hello world from lambda : 0,901

  inc_alt_alt(); 
  func();//prints: Hello world from lambda : 0,902

  std::cout << " x :" << x << "; y :" << y << std::endl;  // x :1; y :902

\end{lstlisting}
Listing \ref{listing1} illustrates the use of capture specifiers.
The lambda $func$ has no arguments and prints the value of the two free variables $x$ and $y$ to stdout. 
The free variables $x$ and $y$ are defined earlier in the code and are initialized to 0 and 42 respectively. 
The capture specifier of $func$ is $[x,\&y]$.  
Hence $x$ is captured by value and $y$ be reference.
The next three lambda's increment $x$ and $y$.
The lambda $inc$ captures y by reference.
$inc\_alt$ on the other hand captures $y$ by value and can change $y$ because the keyword $mutable$ is used its the definition  
$inc\_alt\_alt$ captures the complete environment by reference, and increments both x and y.

Each time y is changed $func$ is called to show the current state of its free variables $x$ and $y$.
The comment following $func()$ shows its output. 

Since $y$ is captured by reference is can be changed through side effects.
On the other hand $x$ is captured once and remains the same.
%
\begin{lstlisting}[caption=Implementation of factorial using lambda recursion, label=lr]
[...]
  // as opposed to [=] or [] or [l]
  std::function<int (int)> factorial = [&factorial] (int x) ->int {
    std::cout << x << ",";
    if (x == 0) return 1;
    return x * factorial(x-1);
    
  };
  auto res = factorial(10);
  std::cout << std::endl;
  std::cout << "res : " << res << std::endl;
  //prints : 10,9,8,7,6,5,4,3,2,1,0,
 //     res : 3628800
\end{lstlisting}
%
Listing $\ref{lr}$ shows a recursive implemention of the factorial $n!$. 
The return type is specified using the return specifier.
Notice that the lambda itself needs to be captured by reference.
The value of the argument is printed each time $factorial$ is called and the output for $factorial(10)$ is shown in the comments.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section*{Partial Function Application}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A partially applied function is created when a function is called with fewer arguments than specified in its argument list.
In that case a lambda is returned with the remainder of the arguments \cite{field}.
C++ supports partial function application through {\em std::bind} \cite{std::bind} and placeholders \cite{std::placeholder}.
Both are defined in the header $<functional>$. 
Placeholders are in the namespace $std::placeholders$ and are named $\_1$, $\_2$ etc.

std::bind takes a callable object or a function pointer as it's first argument and returns an other function object.
Subsequent arguments to std::bind are either values or placeholders.

The position of the values and placeholders corresponds to the position of the argument in the argument list of the input function. 
A value is bound to the argument of the input function and a placeholder creates an argument for the callable returned by std::bind.
The number of arguments is equal to the number of distinct placeholders.
%
\begin{lstlisting}[caption=std::bind example, label=std::bind::example]
[...]
 
  auto repeat = [](int n, double y, std::function<double(double)> f) { 
    while (n-- > 0) {
      y = f(y);
    }
    return y;
  };

  auto rpl    = std::bind (repeat,
			   std::placeholders::_1,
			   std::placeholders::_1,
			   std::placeholders::_2);

  std::function<double (double)> l1     = [](double x) { return 2*x-0.906;};
  auto val = rpl(9, l1);
  std::cout << " result : " << val << std::endl; // print 4145.03

\end{lstlisting}
%
Listing \ref{std::bind::example} creates a function $rpl$ which repeatedly calls function $l1$. 
$rpl$ is created using std::bind and std::placeholders on the higher order function $repeat$.
The function passed in as the third of $repeat$ is in the body of a while loop. 
This function is initially called with the value of the \nth{2} argument.
The first argument is the number of repetitions.
Through std::bind $rpl$ sets the number of repetitions equal to the initial value because the first and second argument of $repeat$ are bound to the same placeholder $std:placeholders::\_1$. 
The result of $rpl(l1,9)$  is printed to stdout, and it's value is shown in the comment.

%%%%%%%%%%%%%%%%%%%%%%%%%COMMENT OUT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section*{Currying}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\em Currying} turns any function into a higher order function of one variable \cite{field}.
The curry of the function returns a partially applied version of the original.

The operator $curry2$ is a higher order function which takes a binary function as input 
and returns a unary higher order function.
That function is the curry of the binary function.
%%--------
\begin{eqnarray*}
curry2 \; :: \; ((a,b) \rightarrow c) &\rightarrow& (a \rightarrow b \rightarrow c) \\
f::(a,b) \rightarrow c &\Rightarrow&  (curry2\;f)::a \rightarrow b \rightarrow c 
\end{eqnarray*}
%-----------------------------
When the curried version of $f$ is called with an argument of type $a$ it returns another unary function 
Calling this function with an argument of type $b$ returns the same value as $f$.
%%%
\begin{eqnarray*}
plus\;:\;:(int \;x, int \;y) \;::int = x+y &\Rightarrow& cplus(int\; x) \;::\; (int \rightarrow int)  \\
                                                             & & \rightarrow (int \; y) \;::\; int \rightarrow x+y  \\
plus(5,6) = 11 &\Leftrightarrow&(curry2 \; plus)(5)(6) = 11
\end{eqnarray*}
%%---------
$(curry2 plus)$ is the curried version of $plus$.
{\em curry2 plus)(5)} returns a lambda which represents the $plus$ function partially applied to 5. 
When this partially applied version of $plus$ is called with 6 an unsurprising 11 is the result.

Listing \ref{curry2} shows an implementation of curry2 in C++: 
%--
\begin{lstlisting}[caption=curry for binary operators, label=curry2]
template <typename R, typename T, typename U>
std::function<std::function<R (U)> (T)> curry(std::function<R (T,U)> op)
{
  return [=] (T x) { return [=] (U y) {return op(x, y);};};
}
  auto l = curry<int,int, int> ([](int x, int y) { return (5 + x) * y;});
  std::cout << l(1)(1) << std::endl; //prints 6
\end{lstlisting}
%---
Currying plays an important role in functional programming \cite{field}. 
It simplifies the design of higher order functions because we only have to consider unary functions.

C++ does not provide a curry operator and functions are not written in curried form. 
Compare this to Haskell where functions are curried by default \cite{lipovaca, hutton}.
However writing a curry operator or writing curried versions of a function has become a lot easier now that lambda's are supported.
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%COMMENT OUT END%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\section*{Map, zipWith and Zip}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
{\em map} applies a function $f$ of type $a \rightarrow b$ to each element of a list $[a]$ and returns a new list $[b]$. 
%---
\begin{eqnarray*}
map \;::\; (a \rightarrow b) \rightarrow [a] \rightarrow [b]
\end{eqnarray*}
%----

The implemention of the map function using stl algorithms requires an interface which takes a unary callable as well as a set of iterators marking the start and end of the container over which the callable is applied.
That matches the interface of $std::transform$ function found in the $<algorithm>$ header file \cite{josuttis, std::transform}.
$std::transform$ takes a unary callable object as input and applies it to the elements of the input container.
It puts the results in the destination range. 
The return value is an iterator past the last element of the destination range. 
\newline
%
%\footnote {
$std::for\_each$ in the header $<algorithm>$ has an interface that is close but it implements an imperative for-loop which  changes each element of the input container.
\cite{std::foreach, josuttis}.
%}
\begin{comment}
%%---
\[
\begin{array}{rll}
\mbox{\bf template}<&\mbox{\bf typename}\; input\_container\_iterator, \\
               &\mbox{\bf typename} \; output \_container\_iterator, \\
             &\mbox{\bf typename} \; unary\_operation >&\\
output\_container\_iterator\;& \mbox{\bf transform}\\
&( input\_container\_iterator\; begin_1, \\
& input\_container\_iterator \; end_1, \\
& output\_container\_iterator \; destination_1, \\
& unary\_operation \; unary_{op} );
\end{array}
\]
%%------------
\end{comment}

Listing \ref{map} shows a possible implementation of the map function for a std::forward\_list \cite{std::forward_list, josuttis}.

\begin{lstlisting}[caption=map for std::forward\_list,label=map]
template<typename A, typename F>
auto map (F f, const std::forward_list<A>& L) -> std::forward_list<decltype(f(A()))>
{
  std::forward_list<decltype(f(A()))> H;
  std::transform(L.begin(), L.end(), std::front_inserter(H), f);
  H.reverse();
  return H;
}
\end{lstlisting}

The template for map takes two type parameters $A$ and $F$. 
Parameter $A$ specifies the type of the element in the input container $L$.  
Parameter $F$ specifies a very generic callable. 
%--
%\footnote{
%std::function could have been used to provide a more typesafe interface.
%However that would not allow us to use in-line lambda functions.
%The type of each lambda is unique and therefore would not be converted to std::function.
%}
%--
The return type of map is declared as $auto$ because it depends on the types of the input arguments.
The declaration is deferred until after their declaration and is determined by applying $decltype$ to the expression $f(A())$ \cite{josuttis, auto, decltype}.

%-----
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%COMMENTED OUT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\begin{lstlisting}[caption=using std;:bind to combine functions, label=combine ]
[...]
std::function< std::function <int(int)>(int)> cplus   = [] (int x) {
    return [=] (int y) {
      return 4 * x + y;
    };
  };

 auto l = std::bind([](std::function<int(int)> f){return f(2);},
		     std::bind(cplus, std::placeholders::_1));

  map(show, map(l, L)); //prints 6,270,358,94,182,6,14,398,-358,

\end{lstlisting}
%----
Listing \ref{combine} illustrates how function combination can be used to limit the number of iterations and list copies.
The resulting function $l$ is then mapped over list $L$.
The inner bind takes the function $cplus$ as the first argument and has a placeholder $\_1$ as the second argument.
The callable object returned by the inner bind is then used as the argument input to the function of the outer bind. 
The function of the outer bind is a lambda which has a function as input.
In the body of the lambda this function is called with 2 and it's result is returned.
The resulting callable object $l$ is the function is $f(x)\ = 4 * x + 2$.
The placeholder is bound to the first argument of $cplus$ and 2 is used as the value for the second argument.
The result of mapping is printed to std::cout and the output is shown in the comment. 
Note that 94 the result of 4 * 23 + 2, 182 the result of 4 * 45 + 2 etc.
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%COMMENTED OUT END%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
$std::transform$ function has an overloaded implementation which applies a binary function to two input ranges and copies the result to the destination range \cite{jouttis, std::transform}. 
It returns an iterator past last element in the destination range.
%%---------------
\begin{comment}
\[
\begin{array}{rll}
\mbox{\bf template}<& \mbox{\bf typename}\; input\_container\_iterator_1, \\
                &\mbox{\bf typename}\; input\_container\_iterator_2, \\
               &\mbox{\bf typename} \; output \_container\_iterator, \\
             &\mbox{\bf typename} \; binary\_operation> &\\
output\_container\_iterator\;& \mbox{\bf transform}\\
&( input\_container\_iterator_1\; begin_1, \\
& input\_container\_iterator_1 \; end_1, \\
&input\_container\_iterator_2\; begin_2, \\
& output\_container\_iterator \; destination_1, \\
& binary\_operation \; binary_{op} );
\end{array}
\]
%%------------
%
\end{comment}
This function signature is similar to that of the $zipWith$ function found in Haskell \cite{lipovaca, hutton}:
%%---
\begin{eqnarray*}
zipWith \;::\; (a \rightarrow b \rightarrow c ) \rightarrow [a] \rightarrow [b] \rightarrow [c] \\
zip \;::\;  [a] \rightarrow [b] \rightarrow [(a,b)]
\end{eqnarray*}
%%---
$zipWith$ applies a curried binary function to two list with elements of type $a$ and $b$.
The result is a list of type $c$.
A closely related and widely used function is $zip$ which takes two lists and returns a list of pairs \cite{zip}.
%
\begin{lstlisting}[caption=zipWith and zip implemented with std::transform, label=zipWith]
template<typename A, typename B, typename F>
auto zipWith (F f, const std::forward_list<A>& L, const std::forward_list<B>& R) -> std::forward_list<decltype(f(A(),B()))>
{
  std::forward_list<decltype(f(A(),B()))> H;
  std::transform(L.begin(), L.end(), R.begin(), std::front_inserter(H), f);
  H.reverse();
  return H;
}
template<typename A, typename B>
std::forward_list<std::tuple<A,B>> zip (const std::forward_list<A>& L, const std::forward_list<B>& M) 
{
  return zipWith([] (const A& a, const B& b) {return std::make_tuple(a,b);}, L, M);
}

\end{lstlisting}

Listing \ref{zipWith} shows the implemention of $zipWith$ and $zip$ for a $std::forward\_list$.
Similar to the $map$ function the type of the return list is determined by calling decltype on the expression $F(A(),B())$.
%
\begin{lstlisting}[caption=zipping two lists, label=zipexample ]
   [...]
  std::forward_list<int>  L = {1,67,89,23,45,1,3,99,-90};
  std::forward_list<char> R = {'a','b','l','u','t','v','r','6','h'};

  auto H2 = zip (L, R);
  map([] (std::tuple<int,char> v) { std::cout << v << ","; return v;},H2); 
 //prints : (1,a),(67,b),(89,l),(23,u),(45,t),(1,v),(3,r),(99,6),(-90,h),
\end{lstlisting}
Listing \ref{zipexample} illustrates the use of zip on two lists.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%BEGIN COMMENT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
%
%
%%------------
\begin{lstlisting}[caption=curried version of zipWith, label=curriedZipWith]
template<typename A, typename B, typename F>
auto zipWith (F f) {
  return [=](const std::forward_list<A>& L) {
    return [=](const std::forward_list<B>& R) -> std::forward_list<decltype(f(A(),B()))> {
      std::forward_list<decltype(f(A(),B()))> H;
      std::transform(L.begin(), L.end(), R.begin(), std::front_inserter(H), f);
      H.reverse();
      return H;
    };
  };
};
 [....]
  auto op = [] (int x, char z) {
      return std::make_tuple(x,z);
  };
  auto res = zipWith<int,char>(op)(L)(R);
  map([] (std::tuple<int,char> v) { std::cout << v << ","; return v;}, res);
  //prints : (1,a),(67,b),(89,l),(23,u),(45,t),(1,v),(3,r),(99,6),(-90,h),
\end{lstlisting}
%%---------
%
Listing \ref{curriedZipWith} is closer to zipWith's curried version shown in the function signature above.
The listing shows the same zip operation as the one in listing \ref{zipexample}.
The line noise in this version has increased because the curried version  requires explicit template instantiation. 
C++'s type system is not powerful enough to infer the types from type of the arguments to {\em op}.
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%END OF COMMENT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section*{Reduce and the List Monad}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The type signature for reduce is:
\begin{eqnarray*}
reduce \;::\; (a \rightarrow b \rightarrow a) \rightarrow a \rightarrow [b] -> \rightarrow a
\end{eqnarray*}
$reduce$ moves or folds a binary operation over a list and returns a result.
%----
%\footnote{In fact 
Another name for $reduce$ is $foldl$. There also exists a closely related dual foldr.
I refer to \cite{bird, hutton} for more on their relationship.
%%}
%----

The type of the first argument of to the binary operation is the same as the type returned by $reduce$. 
It's also the type of the first variable encountered after operator specification.
Therefore this variable is used as the first argument to the binary operation, together with first element of the list $[b]$.

$map$ can be implemented in terms of $reduce$, which makes $reduce$ more powerful.
In that case the type a would be the list type, and the initial value would be the empty list.
The binary operator would then concatenate the result of a unary operation to the list.

The $std::accumulate$ function found in the $<numeric>$ header takes a binary operator and a couple of list iterators as input and returns the result of mapping the binary operator over the range \cite{josuttis,std::accumulate}.

%%---------------
\begin{comment}
\[
\begin{array}{rll}
\mbox{template}<&\mbox{typename}\; input\_container\_iterator, \\
               &\mbox{typename}  \; T \\
             &\mbox{typename} \; binary\_operation >&\\
T \;& \mbox{\bf accumulate}\\
&( input\_container\_iterator\; begin, \\
& input\_container\_iterator\; end, \\
& T \; initial\_value, \\
& binary\_operation \; binary_{op} );
\end{array}
\]
\end{comment}
%%------------
%
The main difference between the function signature of $std::accumulate$ and $reduce$ is the order of the arguments.
%%%%%%%->curry no longer used -> and the lack of curry.
\begin{lstlisting}[caption=example of std::accumulate,label=std::accumulate]
std::forward_list<int> L = {1,-6,23,78,45,13};
  auto max = [] (int x, int y) { return (x > y) ? x : y;};
  auto res = std::accumulate(L.begin(), L.end(), std::numeric_limits<int>::min(), max);
  std::cout << "maximum : " << res << std::endl; //prints 78
\end{lstlisting}
%%---------------
In listing \ref{std::accumulate} $std::accumulate$ is used to find the maximum value in a list.
The search is initialized by $std::numeric\_limits<int>::min$ which returns the smallest possible integer value \cite{josuttis}.
The binary operation is a lambda wrapped around the compare operator.
The result returned by std::accumulate is printed to stdout and the unsurprising result is shown in the comment.
%
\begin{lstlisting}[caption=processing a list using reduce,label=premonad]
 auto show   = [] (int v) { std::cout << v << ","; return v;};
  typedef std::list<int> list_t;
  list_t L = {1,-6,23,78,45,13};
  auto m   = [] (list_t L, int y) { L.push_back( 2*y + 1); return L;};
  auto res = std::accumulate(L.begin(), L.end(), list_t(), m);
  map(show,res); //prints 3,-11,47,157,91,27,
\end{lstlisting}
%
In listing \ref{premonad} $std::accumulate$ processes a list by applying an function to each element of the input list and returning the result in a new list.
The body of the lambda $m$ applies the unary operation $op(y)=(2*y+1)$ and concatenates the result to the destination list. 
%
%-----------------------
\begin{comment}
%
\begin{lstlisting}[caption=unary operation and reduce,label=premonad2]
  [...]	
  typedef std::forward_list<int> list_t;
  list_t L         = {1,-6,23,78,45,13};
  auto op       = [] (int y) {return list_t({2*y+1});};
  auto concat = [] (list_t A, list_t B) { A.splice_after(A.before_begin(), B); return A;};
  auto bind    = std::bind(concat, std::placeholders::_1, std::bind(op, std::placeholders::_2));
  auto show   = [] (int v) { std::cout << v << ","; return v;};
  auto res       = std::accumulate(L.begin(), L.end(), list_t(), bind);
  map(show, res); //prints 27,91,157,47,-11,3,(i.e reverse order)
\end{lstlisting}
%
Listing \ref{premonad2} re-factors the code in listing \ref{premonad} by separating the unary operation and the list concatenation.
%
\end{comment}
%----------------------
\begin{lstlisting}[caption=the list monad, label=listmonad]
  template<typename A, typename F>
auto mapM (F f, std::forward_list<A> L) -> decltype(f(A()))
{
  typedef typename decltype(f(A()))::value_type ret_t;
  L.reverse();
  auto concat = [] (std::forward_list<ret_t> L, std::forward_list<ret_t> R) { 
    L.splice_after(L.before_begin(), R); 
    return L;
  };
  auto op     = std::bind(concat, std::placeholders::_1, std::bind(f, std::placeholders::_2));
  return std::accumulate(L.begin(), L.end(), std::forward_list<ret_t>(), op);;
}
\end{lstlisting}
%
Listing \ref{listmonad} shows the implemention of a function called mapM based on the refactoring of the code in listing \ref{premonad}.
It has seperated the unary operation and the list concatenation.
At first blush this looks like a clunky reimplementation of the $map$ function but in fact it's more powerful.
Just like map, mapM takes a unary function f, and a list and returns a list:
\begin{eqnarray*}
mapM :: (a \rightarrow [b]) \rightarrow [a] \rightarrow [b]
\end{eqnarray*}
The main difference the function signature of the unary operator : $a \rightarrow [b]$. 
It returns a list of values rather than a value. 
This makes mapM more powerful than map.
%
\begin{lstlisting}[caption=example of mapM, label=mapM] 
[...]
  auto show   = [] (std::tuple<int,char> v) { std::cout << v << ","; return v;};
  static char digits[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' };
  typedef std::forward_list<std::tuple<int, char>> list_t;
  auto op  = [=] (int y) {return list_t({std::make_tuple(y, digits[abs(y)%10])});};
  map(show, mapM(op, std::forward_list<int>({1,-6,23,78,45,13})));
  //prints :(1,b),(-6,g),(23,d),(78,i),(45,f),(13,d),
\end{lstlisting}
In listing \ref{mapM} $mapM$ maps unary operator $op$ over the list $[1,-6,78,45,13]$ and returns a list where each number is combined with  a character in the $digits$ list. 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%COMMENT OUT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}
\begin{lstlisting}[caption=comparing with map, label=mapMvsmap] 
[...]
  auto res = map(op, std::forward_list<int>({1,-6,23,78,45,13}));
  
  for (auto& el : res) {
    std::cout << "[";
    map(show, el);
    std::cout << "], ";
  }
  //prints :[(1,b),], [(-6,g),], [(23,d),], [(78,i),], [(45,f),], [(13,d),]
\end{lstlisting}
%
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%COMMENT OUT END%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
The binary operation $op$ in listing \ref{mapM} could have returned more than one element, or an empty list.
Regardless of what it returns mapM returns a {\em list} of values.

If you map an operation $a \rightarrow [b]$ over a list $[a]$ with $map$ a list of lists $[[b]]$ is returned. %%%, as shown in listing \ref{mapMvsmap}.
A list of a list of values is a fundamentally different data type than a list of values. 
In C++ its type would be $std::forward\_list<std::forward\_list<T>>>$ where template parameter $T$ represents the type of the values in the inner list.
The problem here is that the structure of the container has changed from a simple list $std::forward\_list<T>$ to a nested list.
$mapM$ concatenates the results of the binary operator $op$ and the structure of the container remains the same.

In a typical scenario you'd want to apply a number of operations to a list.
mapM allows each function to have the same signature : It takes a single element and returns a list of elements.
By contrast the next application of a function on a list returned by map, would require an iteration over the result list.

The type signature of mapM is that of the monad implemention for lists \cite{bird, lipovaca}.
The use of monads and other types provide a powerful extension of the functional approach \cite{yorgey}.
I hope to discuss the support for those in a follow up article.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section*{Conclusions}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
This article looked at basic functional techniques, like lambda expressions and closures, partial function application, map and reduce.
%currying,

It briefly touched on a more powerful, monadic form of the map function.
The ability to use these functional techniques has become possible because of recent additions to the C++ standard.
However an important technique like currying is well supported.
%%%%%%Currying can be implemented by the programmer, but its use introduce some added line noise.
The use of functional features does seem to introduce a lot of accolades, returns and semi-colons.
In addition the error messages generated by the compiler can be quite daunting.

Functional programming emphasizes referential transparency through the use of immutable state.
In the implementations of map and reduce shown here new lists are created containing the changed data elements.
To be referentially transparent requires straight forward and simple copy semantics.
That in turn implies the use of simple data types, like $std::tuples$, which don't maintain state and behave like values \cite{tuples}.

The creation of a new list  $map$ and $reduce$ with copies of the data items by incurs a performance penalty.
In languages designed for functional programming the cost of this approach is reduced because items that remain unchanged are in fact reused \cite{field}. 
In C++ the tradeoff of referential transparency needs to be traded off against performance.

The extension of the functional approach to a richer class of data structures introduces a whole new set of concepts \cite{bird,lipovaca,yorgey}.
To what extend those concepts are supported by C++ will be the subject of an other paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}
%--
\bibitem{stroustrup}
Bjarne Stroustrup \\
{\em The C++ Programming Language} \\
Addison-Wesley, 1997, \nth{3} edition.
%---
\bibitem{mcnamara}
Brian McNamara, Yannis Smaragdakis  \\
Functional programming with the FC++ library. \\
J. Funct. Program. 14(4): 429-472 (2004)
%---
\bibitem{vandevoorde}
David Vandevoorde, Nicolai M. Josuttis \\
{\em C++ Templates} \\
Addison-Wesley, 2003.
%
\bibitem{alexan}
Andrei Alexandrescu \\
{\em Modern C++ Design} \\
Addison-Wesley, 2001
%
\bibitem{lipovaca}
 Miran Lipova\v{c}a\\
{\em Learn you a Haskell for great good : a beginner's guide}\\
no starch press, San Fransisco, 2011
%--
\bibitem{hutton} 
Graham Hutton \\
{\em Programming in Haskell} \\
Cambridge University Press, 2007
%---
\bibitem{bird}
Richard Bird
{\em Introduction to Functional Programming using Haskell}
Prentice Hall Europe, 1998, \nth{2} edition
%-----
\bibitem{field}
Anthony J. Field and Peter G. Harrison \\
{\em Functional Programming} \\
Addison-Wesley, 1989.
%------
\bibitem{scott}
Michael L. Scott \\
{\em Programming Language Pragmatics} \\
Morgan Kauffmann, 2006, \nth{2} edition
%-----
\bibitem{designpatterns}
Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides \\
{\em Design Patterns : Elements of Reusable Object-Oriented Software} \\
Addison Wesley Longman, 1995
%----
\bibitem{josuttis}
Nocolai M. Josuttis \\
{\em The C++ Standard Library}\\
Addison-Wesley, \nth{2} edition.
%---
\bibitem{sourcecode}
\underline{\em https://github.com/fons/functional-cpp}
%---
\bibitem{macports}
\underline {\em http://www.macports.org/}
%--
\bibitem{lambdaref}
\underline{\em http://en.cppreference.com/w/cpp/language/lambda}
%---
\bibitem{std::function}
\underline{\em http://en.cppreference.com/w/cpp/utility/functional/function}
%---
\bibitem{auto}
\underline{\em http://en.cppreference.com/w/cpp/language/auto}
%---
\bibitem{std::bind}
\underline{\em http://en.cppreference.com/w/cpp/utility/functional/bind}
%--
\bibitem{std::placeholder}
\underline{\em http://en.cppreference.com/w/cpp/utility/functional/placeholders}
%----
\bibitem{std::foreach}
\underline{\em http://en.cppreference.com/w/cpp/algorithm/for\_each}
%
\bibitem{std::forward_list}
\underline{\em http://en.cppreference.com/w/cpp/algorithm/forward\_list}

%----
\bibitem{std::transform}
\underline {\em http://en.cppreference.com/w/cpp/algorithm/transform}
%---
\bibitem{decltype}
\underline{\em http://en.cppreference.com/w/cpp/language/decltype}
%---
\bibitem{std::accumulate}
\underline{\em http://en.cppreference.com/w/cpp/algorithm/accumulate}
%----
\bibitem{zip}
zip function in Python \\
\underline{\em  http://docs.python.org/2/library/functions.html\#zip}\\
zip function in Ruby \\
\underline{\em http://ruby-doc.org/core-2.0/Array.html\#method-i-zip} \\
Support in Perl \\
\underline{\em http://search.cpan.org/~lbrocard/Language-Functional-0.05/Functional.pm}  
%----
\bibitem{yorgey}
Brent Yorgey \\
{\em The Typeclassopedia}
The Monad.Reader, Issue 13; p17; 12 March 2009
\underline{\em www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf}
%----
\bibitem{tuples}
\underline{\em http://en.cppreference.com/w/cpp/utility/tuple}
%----

%%---non bibitems below this line
%%
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
